/*
This script is very messy and it will be hard to expand in the future but for the moment it works and will do.
*/
use serde::Deserialize;
use std::fs::{File, OpenOptions};
use std::io::Write;

const IMPORTS: &'static str = "use alloc::vec::Vec;\nuse alloc::vec;";
const INSTRUCTION_SET_PATH: &'static str = "base_instruction_set.csv";
const OPCODE_OUTPUT_PATH: &'static str = "src/instruction.rs";
const EXECUTE_OUTPUT_PATH: &'static str = "src/execute_instruction.rs";
const OPCODE_ENUM_NAME: &'static str = "Instruction";
const REGISTER_TYPE_NAME: &'static str = "Register";
const ADDRESS_TYPE_NAME: &'static str = "Address";
const IMMEDIATE_TYPE_NAME: &'static str = "Immediate";
const EXECUTE_TRAIT_NAME: &'static str = "ExecuteInstruction";
const OPCODE_TAIL: &'static str = "}\n\n";
const OPCODE_DERIVE_TRAITS: &'static str = "Debug, Clone, Copy, PartialEq";
const OPCODE_REGISTER_COUNT_METHOD_HEADER: &'static str =
    "pub const fn register_count(opcode: u8) -> Option<usize> {\n";
const OPCODE_ADDRESS_COUNT_METHOD_HEADER: &'static str =
    "pub const fn address_count(opcode: u8) -> Option<usize> {\n";
const OPCODE_IMMEDIATE_COUNT_METHOD_HEADER: &'static str =
    "pub const fn immediate_count(opcode: u8) -> Option<usize> {\n";

const NEW_OPCODE_OPENING_IF:[&'static [u8]; 3] =
    [b"if registers.len() != Self::register_count(opcode)? || addresses.len() != Self::address_count(opcode)? || immediates.len() != Self::immediate_count(opcode)? {",
    b"\treturn None;", b"}"];

type MethodDetails = Vec<(String, Vec<&'static str>, String, u8, String)>;

macro_rules! create_property_method {
    ($header:expr, $method_name:ident, $type_name:ident) => {
        fn $method_name(base_indent: &[u8], file: &mut File, opcodes: &MethodDetails) {
            file.write(base_indent)
                .expect("Unable to write base indent");
            file.write($header.as_bytes())
                .expect("Unable to write property method header.");
            file.write(base_indent)
                .expect("Unable to write base indent");
            file.write(b"\t return Some(match opcode {\n")
                .expect("Unable to write step indent");

            for (_opcode, fields, variant, dec, _order) in opcodes {
                file.write(base_indent)
                    .expect("Unable to write base indent");
                file.write(b"\t\t").expect("Unable to write step indent");

                let mut count = 0;

                for field in fields {
                    if *field == $type_name {
                        count += 1;
                    }
                }

                write!(file, "{} => {}, //{}\n", dec, count, variant)
                    .expect("Unable to write opcode match line");
            }

            if opcodes.len() != 256 {
                file.write(base_indent)
                    .expect("Unable to write base indent");
                file.write(b"\t\t").expect("Unable to write step indent");
                write!(file, "_ => return None,\n")
                    .expect("Unable to write field display information.");
            }

            file.write(base_indent)
                .expect("Unable to write base indent");
            file.write(b"\t});\n").expect("Unable to write next indent");
            file.write(base_indent)
                .expect("Unable to write base indent");
            file.write(b"}\n")
                .expect("Unable to write method termination");
        }
    };
}

#[derive(Deserialize, Debug, PartialEq, Eq, Hash)]
struct Row {
    binary: String,
    decimal: u8,
    hex: String,
    opcode: String,
    description: String,
    immediates: u8,
    registers: u8,
    addresses: u8,
    order: String,
}

fn main() {
    println!("cargo:rerun-if-changed={}", INSTRUCTION_SET_PATH);

    let opcodes = generate_opcodes();
    generate_execute_trait(opcodes);
}

#[inline]
fn opcode_header() -> String {
    return format!(
        "/*\n\
    NOTE: THIS FILE IS AUTOGENERATED.\n\
    */\n\
    \n\
    use crate::{};\n\
    use crate::{};\n\
    use crate::{};\n\
    use crate::InstructionArgument;\n\
    \n\
    {}\
    \n\
    \n\
    #[derive({})]\n\
    pub enum {} {{\n",
        REGISTER_TYPE_NAME,
        ADDRESS_TYPE_NAME,
        IMMEDIATE_TYPE_NAME,
        IMPORTS,
        OPCODE_DERIVE_TRAITS,
        OPCODE_ENUM_NAME
    );
}

#[inline]
fn execute_header() -> String {
    return format!(
        "/*\n\
    NOTE: THIS FILE IS AUTOGENERATED.\n\
    */\n\
    \n\
    use crate::{};\n\
    use crate::{};\n\
    use crate::{};\n\
    use crate::{};\n\
    \n\
    pub trait {} {{\n\
    \ttype Output;\n\
    \n\
    \tfn execute_instruction(&mut self, instruction: {}) -> Self::Output {{\n\
    \t\treturn match instruction {{\n",
        REGISTER_TYPE_NAME,
        ADDRESS_TYPE_NAME,
        IMMEDIATE_TYPE_NAME,
        OPCODE_ENUM_NAME,
        EXECUTE_TRAIT_NAME,
        OPCODE_ENUM_NAME
    );
}

#[inline]
fn opcode_impl_display_header() -> String {
    return format!(
        "impl core::fmt::Display for {} {{\n\
        \tfn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {{\n\
        \t\t return write!(f, \"{{}}\", match self {{\n",
        OPCODE_ENUM_NAME
    );
}

#[inline]
fn opcode_impl_into_bytes_header() -> String {
    return format!(
        "impl Into<Vec<u8>> for {} {{\n\
        \t fn into(self) -> Vec<u8> {{\n\
        \t\t return match self {{\n",
        OPCODE_ENUM_NAME
    );
}

#[inline]
fn opcode_impl_header() -> String {
    return format!("impl {} {{\n", OPCODE_ENUM_NAME);
}

#[inline]
fn opcode_new_header() -> String {
    return format!(
        "pub fn new(opcode: u8, registers: Vec<{}>, addresses: Vec<{}>, immediates: Vec<{}>) -> Option<Self> {{\n",
        REGISTER_TYPE_NAME,
        ADDRESS_TYPE_NAME,
        IMMEDIATE_TYPE_NAME
    );
}

fn generate_opcodes() -> MethodDetails {
    if !std::path::Path::new(INSTRUCTION_SET_PATH).exists() {
        panic!("No instruction set file found at {}", INSTRUCTION_SET_PATH);
    }

    let file = match File::open(INSTRUCTION_SET_PATH) {
        Ok(f) => f,
        Err(e) => {
            panic!(
                "Failed to open the file {}. Error: {}",
                INSTRUCTION_SET_PATH, e
            );
        }
    };

    let mut csv_reader = csv::Reader::from_reader(file);

    let mut rows = Vec::new();

    for record in csv_reader.records() {
        if let Ok(record) = record {
            match record.deserialize::<Row>(None) {
                Ok(r) => rows.push(r),
                Err(e) => {
                    panic!("Could not deserialize row. Error: {}", e);
                }
            }
        } else {
            panic!("Could not access row.");
        }
    }

    let mut file = match OpenOptions::new()
        .create(true)
        .write(true)
        .truncate(true)
        .open(OPCODE_OUTPUT_PATH)
    {
        Ok(f) => f,
        Err(e) => {
            panic!(
                "Failed to open the file {}. Error: {}",
                INSTRUCTION_SET_PATH, e
            );
        }
    };

    let mut method_details = Vec::new();

    file.write_all(opcode_header().as_bytes())
        .expect("Unable to write header to file.");

    for row in rows {
        let mut opcode = row.opcode.clone();
        let variant_name = format!("{}{}", opcode.remove(0).to_uppercase().to_string(), opcode);
        let mut variant = format!("\t{}", variant_name);

        let mut fields = Vec::new();

        for _ in 0..row.immediates {
            fields.push(IMMEDIATE_TYPE_NAME);
        }

        for _ in 0..row.registers {
            fields.push(REGISTER_TYPE_NAME);
        }

        for _ in 0..row.addresses {
            fields.push(ADDRESS_TYPE_NAME);
        }

        if fields.len() != 0 {
            variant.push('(');
            variant.push_str(&fields.join(", "));
            variant.push(')');
        }

        variant.push_str(", \n");

        method_details.push((row.opcode, fields, variant_name, row.decimal, row.order));

        file.write(variant.as_bytes())
            .expect("Unable to write a row");
    }

    file.write(OPCODE_TAIL.as_bytes())
        .expect("Unable to write tail to file.");

    generate_opcode_methods(&mut file, &method_details);

    file.write(opcode_impl_display_header().as_bytes())
        .expect("Unable to write header to file.");

    // Generate the display trait
    for (opcode, fields, variant, _, _order) in &method_details {
        let mut lhs = format!("\t\t\tSelf::{}", variant);

        if fields.len() > 0 {
            lhs.push('(');

            for _ in 0..fields.len() - 1 {
                lhs.push_str("_, ");
            }

            lhs.push_str("_)");
        }

        write!(file, "{} => \"{}\",\n", lhs, opcode)
            .expect("Unable to write field display information.");
    }

    file.write_all("\t\t});\n\t}\n}\n\n".as_bytes())
        .expect("Unable to write display tail to file.");

    generate_into_bytes_trait(&mut file, &method_details);

    file.write_all(b"\t\t};\n\t}\n}")
        .expect("Unable to write into trait tail to file");

    return method_details;
}

fn generate_opcode_methods(file: &mut File, opcodes: &MethodDetails) {
    file.write(opcode_impl_header().as_bytes())
        .expect("Failed to write opcode impl header.");

    generate_ordering_array(opcodes, file, "\t");

    generate_register_method(b"\t", file, opcodes);

    file.write(b"\n").expect("Failed to write padding new line");

    generate_address_method(b"\t", file, opcodes);

    file.write(b"\n").expect("Failed to write padding new line");

    generate_immediate_method(b"\t", file, opcodes);

    file.write(b"\n").expect("Failed to write padding new line");

    generate_opcode_from_name_method(b"\t", file, opcodes);

    // Generate the create new opcode
    file.write(b"\n\t")
        .expect("Failed to write padding new line");

    file.write(opcode_new_header().as_bytes())
        .expect("Failed to write Instruction \"new\" method.");

    generate_new_opcode_method(b"\t", file, opcodes);

    file.write(b"\n").expect("Failed to write padding new line");

    generate_type_ordering_function(file, "\t");

    file.write(b"}\n\n")
        .expect("Failed to write impl closing brace");
}

fn generate_opcode_from_name_method(base_indent: &[u8], file: &mut File, opcodes: &MethodDetails) {
    file.write(base_indent)
        .expect("Unable to write base indent");
    file.write(b"pub fn from_string(opcode: &str) -> Option<u8> {\n")
        .expect("Unable to write property method header.");
    file.write(base_indent)
        .expect("Unable to write base indent");
    file.write(b"\t return Some(match opcode {\n")
        .expect("Unable to write step indent");

    for (opcode, _fields, variant, dec, _order) in opcodes {
        file.write(base_indent)
            .expect("Unable to write base indent");
        file.write(b"\t\t").expect("Unable to write step indent");

        write!(file, "\"{}\" => {}, //{}\n", opcode, dec, variant)
            .expect("Unable to write opcode match line");
    }

    file.write(base_indent)
        .expect("Unable to write base indent");
    file.write(b"\t\t").expect("Unable to write step indent");
    write!(file, "_ => return None,\n").expect("Unable to write field display information.");

    file.write(base_indent)
        .expect("Unable to write base indent");
    file.write(b"\t});\n").expect("Unable to write next indent");
    file.write(base_indent)
        .expect("Unable to write base indent");
    file.write(b"}\n")
        .expect("Unable to write method termination");
}

create_property_method!(
    OPCODE_REGISTER_COUNT_METHOD_HEADER,
    generate_register_method,
    REGISTER_TYPE_NAME
);

create_property_method!(
    OPCODE_ADDRESS_COUNT_METHOD_HEADER,
    generate_address_method,
    ADDRESS_TYPE_NAME
);

create_property_method!(
    OPCODE_IMMEDIATE_COUNT_METHOD_HEADER,
    generate_immediate_method,
    IMMEDIATE_TYPE_NAME
);

fn generate_new_opcode_method(inset: &[u8], file: &mut File, opcodes: &MethodDetails) {
    for line in &NEW_OPCODE_OPENING_IF {
        file.write(inset).expect("Failed to write inset");
        file.write(b"\t").expect("Failed to write new line");

        file.write(*line)
            .expect("Failed to write opcode_opening_ifs");
        file.write(b"\n").expect("Failed to write new line");
    }

    file.write(b"\n").expect("Failed to write new line");

    file.write(inset).expect("Failed to write inset");
    file.write(b"\treturn Some(match opcode {\n")
        .expect("Failed to write match start");

    for (_opcode, fields, variant, dec, _order) in opcodes {
        file.write(inset).expect("Unable to write the inset");

        let mut arg_fields = String::new();
        let mut reg_i = 0;
        let mut add_i = 0;
        let mut imm_i = 0;

        for field in fields {
            if *field == REGISTER_TYPE_NAME {
                arg_fields.push_str(&format!("registers[{}], ", reg_i));

                reg_i += 1;
            } else if *field == ADDRESS_TYPE_NAME {
                arg_fields.push_str(&format!("addresses[{}], ", add_i));

                add_i += 1;
            } else if *field == IMMEDIATE_TYPE_NAME {
                arg_fields.push_str(&format!("immediates[{}], ", imm_i));

                imm_i += 1;
            }
        }

        if arg_fields.len() > 0 {
            // Remove ", "
            arg_fields.pop();
            arg_fields.pop();

            write!(file, "\t\t{} => Self::{}({}),\n", dec, variant, arg_fields)
                .expect("Unable to write field creation information.");
        } else {
            write!(file, "\t\t{} => Self::{},\n", dec, variant)
                .expect("Unable to write field creation information.");
        }
    }

    file.write(inset).expect("Unable to write the inset");
    file.write(b"\t\t_ => return None,\n")
        .expect("Failed to write general return");

    file.write(inset).expect("Failed to write inset");
    file.write(b"\t});\n").expect("Failed to write match end");

    file.write(inset).expect("Failed to write inset");
    file.write(b"}\n").expect("Failed to write ending");
}

fn generate_into_bytes_trait(file: &mut File, opcodes: &MethodDetails) {
    file.write(opcode_impl_into_bytes_header().as_bytes())
        .expect("Failed to write bytes header.");

    for (_opcode, fields, variant, dec, _order) in opcodes {
        let inset = "\t\t\t";

        file.write(inset.as_bytes())
            .expect("Unable to write step indent");

        let mut r_count = 0;
        let mut a_count = 0;
        let mut i_count = 0;

        for field in fields {
            if *field == REGISTER_TYPE_NAME {
                r_count += 1;
            } else if *field == ADDRESS_TYPE_NAME {
                a_count += 1;
            } else if *field == IMMEDIATE_TYPE_NAME {
                i_count += 1;
            }
        }

        let mut fields_string = String::new();
        let mut rhs_string = format!("{{\n{}\tlet mut v = vec![{}];\n", inset, dec);

        for i in 0..i_count {
            if i == 0 {
                fields_string.push_str("i, ");
                rhs_string.push_str(&format!(
                    "{}\tv.extend_from_slice(&Into::<[u8; {}::BYTES]>::into(i));\n",
                    inset, IMMEDIATE_TYPE_NAME
                ));
            } else {
                fields_string.push_str(&format!("i{}, ", i));
                rhs_string.push_str(&format!(
                    "{}\tv.extend_from_slice(&Into::<[u8; {}::BYTES]>::into(i{}));\n",
                    inset, IMMEDIATE_TYPE_NAME, i
                ));
            }
        }

        fn register_name(i: u64) -> String {
            if i == 0 {
                return "r".to_string();
            } else {
                return format!("r{}", i);
            }
        }

        for i in 0..r_count {
            fields_string.push_str(&format!("{}, ", register_name(i)));

            if i > 0 && i % 2 == 1 {
                rhs_string.push_str(&format!(
                    "{}\tv.push(({} as u8) << 4 | ({} as u8));\n",
                    inset,
                    register_name(i - 1),
                    register_name(i)
                ));
            } else if i == r_count - 1 {
                rhs_string.push_str(&format!(
                    "{}\tv.push(({} as u8) << 4);\n",
                    inset,
                    register_name(i)
                ));
            }
        }

        for i in 0..a_count {
            if i == 0 {
                fields_string.push_str("a, ");
                rhs_string.push_str(&format!(
                    "{}\tv.extend_from_slice(&Into::<[u8; {}::BYTES]>::into(a));\n",
                    inset, ADDRESS_TYPE_NAME
                ));
            } else {
                fields_string.push_str(&format!("a{}, ", i));
                rhs_string.push_str(&format!(
                    "{}\tv.extend_from_slice(&Into::<[u8; {}::BYTES]>::into(a{}));\n",
                    inset, ADDRESS_TYPE_NAME, i
                ));
            }
        }

        if fields_string.len() > 1 {
            fields_string.pop(); // remove trailing space
            fields_string.pop(); // remove trailing comma

            fields_string = format!("({})", fields_string);
        }

        if i_count == 0 && r_count == 0 && a_count == 0 {
            rhs_string = format!("vec![{}]", dec);
        } else {
            rhs_string = format!("{}{}\tv\n{}}}", rhs_string, inset, inset);
        }

        write!(
            file,
            "Self::{}{} => {},\n",
            variant, fields_string, rhs_string
        )
        .expect("Unable to write opcode match line");
    }
}

fn generate_execute_trait(opcodes: MethodDetails) {
    let mut file = match OpenOptions::new()
        .create(true)
        .write(true)
        .truncate(true)
        .open(EXECUTE_OUTPUT_PATH)
    {
        Ok(f) => f,
        Err(e) => {
            panic!(
                "Failed to open the file {}. Error: {}",
                EXECUTE_OUTPUT_PATH, e
            );
        }
    };

    file.write(execute_header().as_bytes())
        .expect("Unable to write execute trait header");

    for (opcode, fields, variant, _, _order) in &opcodes {
        let mut field_names = Vec::new();

        let mut reg_count = 0;
        let mut imm_count = 0;
        let mut add_count = 0;

        for field in fields {
            if *field == REGISTER_TYPE_NAME {
                field_names.push(format!(
                    "r{}",
                    if reg_count == 0 {
                        String::new()
                    } else {
                        reg_count.to_string()
                    }
                ));

                reg_count += 1;
            } else if *field == IMMEDIATE_TYPE_NAME {
                field_names.push(format!(
                    "i{}",
                    if imm_count == 0 {
                        String::new()
                    } else {
                        imm_count.to_string()
                    }
                ));

                imm_count += 1;
            } else if *field == ADDRESS_TYPE_NAME {
                field_names.push(format!(
                    "a{}",
                    if add_count == 0 {
                        String::new()
                    } else {
                        add_count.to_string()
                    }
                ));

                add_count += 1;
            }
        }

        let field_string = field_names.join(", ");

        if field_string.len() > 0 {
            file.write(
                format!(
                    "\t\t\t{}::{}({}) => self.execute_{}({}),\n",
                    OPCODE_ENUM_NAME, variant, &field_string, opcode, field_string,
                )
                .as_bytes(),
            )
            .expect("Failed to write match arm for execute function");
        } else {
            file.write(
                format!(
                    "\t\t\t{}::{} => self.execute_{}(),\n",
                    OPCODE_ENUM_NAME, variant, opcode
                )
                .as_bytes(),
            )
            .expect("Failed to write match arm for execute function");
        }
    }

    file.write("\t\t};\n\t}\n\n".as_bytes())
        .expect("Unable to write execute_opcode function tail");

    for (opcode, fields, _, _, _order) in opcodes {
        let mut field_names = Vec::new();

        let mut reg_count = 0;
        let mut imm_count = 0;
        let mut add_count = 0;

        for field in fields {
            if field == REGISTER_TYPE_NAME {
                field_names.push(format!(
                    "r{}: {}",
                    if reg_count == 0 {
                        String::new()
                    } else {
                        reg_count.to_string()
                    },
                    REGISTER_TYPE_NAME
                ));

                reg_count += 1;
            } else if field == IMMEDIATE_TYPE_NAME {
                field_names.push(format!(
                    "i{}: {}",
                    if imm_count == 0 {
                        String::new()
                    } else {
                        imm_count.to_string()
                    },
                    IMMEDIATE_TYPE_NAME
                ));

                imm_count += 1;
            } else if field == "Address" {
                field_names.push(format!(
                    "a{}: {}",
                    if add_count == 0 {
                        String::new()
                    } else {
                        add_count.to_string()
                    },
                    ADDRESS_TYPE_NAME
                ));

                add_count += 1;
            }
        }

        let mut field_string = field_names.join(", ");

        if field_string.len() > 0 {
            field_string = format!(", {}", field_string);
        }

        file.write(
            format!(
                "\tfn execute_{}(&mut self{}) -> Self::Output;\n\n",
                opcode, &field_string
            )
            .as_bytes(),
        )
        .expect("Failed to write execute opcode function");
    }

    file.write("}\n\n".as_bytes())
        .expect("Unable to write execute_opcode function tail");
}

fn generate_ordering_array(opcodes: &MethodDetails, file: &mut File, indent: &str) {
    file.write(
        format!(
            "{}const ORDERING_ARRAY: [&'static[u8]; {}] = [",
            indent,
            opcodes.len()
        )
        .as_bytes(),
    )
    .expect("Failed to write generic template for constant array.");

    for (_opcode, fields, _variant, _, order) in opcodes {
        assert_eq!(order.len(), fields.len());

        write!(file, "&[").expect("Failed to write entry");
        for char in order.chars() {
            if char == 'r' {
                write!(file, "0, ").expect("Failed to write entry");
            } else if char == 'i' {
                write!(file, "1, ").expect("Failed to write entry");
            } else if char == 'a' {
                write!(file, "2, ").expect("Failed to write entry");
            } else {
                panic!("Unknown order symbol {}", char);
            }
        }

        write!(file, "], ").expect("Failed to write entry");
    }

    write!(file, "];\n\n").expect("Failed to write closing brace");
}

fn generate_type_ordering_function(f: &mut File, indent: &str) {
    write!(
        f,
        "{}pub const fn get_type_for_index(opcode: u8, index: usize) -> Option<u8> {{\n",
        indent
    )
    .expect("Failed to write type ordering function line.");
    write!(
        f,
        "{}\tif opcode as usize >= Self::ORDERING_ARRAY.len() {{\n",
        indent
    )
    .expect("Failed to write type ordering function line.");
    write!(f, "{}\t\treturn None;\n", indent)
        .expect("Failed to write type ordering function line.");
    write!(f, "{}\t}}\n\n", indent).expect("Failed to write type ordering function line.");
    write!(
        f,
        "{}\tif index >= Self::ORDERING_ARRAY[opcode as usize].len() {{\n",
        indent
    )
    .expect("Failed to write type ordering function line.");
    write!(f, "{}\t\treturn None;\n", indent)
        .expect("Failed to write type ordering function line.");
    write!(f, "{}\t}}\n\n", indent).expect("Failed to write type ordering function line.");
    write!(
        f,
        "{}\treturn Some(Self::ORDERING_ARRAY[opcode as usize][index]);\n",
        indent
    )
    .expect("Failed to write type ordering function line.");
    write!(f, "{}}}\n", indent).expect("Failed to write type ordering function line.");
}
