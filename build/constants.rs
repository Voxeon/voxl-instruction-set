pub const BASE_IMPORTS: &'static str = "use alloc::vec::Vec;\nuse alloc::vec;";
pub const INSTRUCTION_SET_PATH: &'static str = "base_instruction_set.csv";
pub const OPCODE_OUTPUT_PATH: &'static str = "src/instruction.rs";
pub const EXECUTE_OUTPUT_PATH: &'static str = "src/execute_instruction.rs";
pub const OPCODE_ENUM_NAME: &'static str = "Instruction";
pub const REGISTER_TYPE_NAME: &'static str = "Register";
pub const ADDRESS_TYPE_NAME: &'static str = "Address";
pub const IMMEDIATE_TYPE_NAME: &'static str = "Immediate";
pub const INSTRUCTION_ARGUMENT_TRAIT_NAME: &'static str = "InstructionArgument";
pub const EXECUTE_TRAIT_NAME: &'static str = "ExecuteInstruction";
pub const OPCODE_TAIL: &'static str = "}\n\n";
pub const OPCODE_DERIVE_TRAITS: &'static str = "Debug, Clone, Copy, PartialEq";
pub const OPCODE_REGISTER_COUNT_METHOD_HEADER: &'static str =
    "pub const fn register_count(opcode: u8) -> Option<usize> {\n";
pub const OPCODE_ADDRESS_COUNT_METHOD_HEADER: &'static str =
    "pub const fn address_count(opcode: u8) -> Option<usize> {\n";
pub const OPCODE_IMMEDIATE_COUNT_METHOD_HEADER: &'static str =
    "pub const fn immediate_count(opcode: u8) -> Option<usize> {\n";

pub const NEW_OPCODE_OPENING_IF:[&'static [u8]; 3] =
    [b"if registers.len() != Self::register_count(opcode)? || addresses.len() != Self::address_count(opcode)? || immediates.len() != Self::immediate_count(opcode)? {",
        b"\treturn None;", b"}"];

#[inline]
pub fn opcode_header() -> String {
    return format!(
        "/*\n\
    NOTE: THIS FILE IS AUTOGENERATED.\n\
    */\n\
    \n\
    use crate::instruction_arguments::{{{}, {}, {}, {}}};\n\
    \n\
    {}\
    \n\
    \n\
    #[derive({})]\n\
    pub enum {} {{\n",
        REGISTER_TYPE_NAME,
        ADDRESS_TYPE_NAME,
        IMMEDIATE_TYPE_NAME,
        INSTRUCTION_ARGUMENT_TRAIT_NAME,
        BASE_IMPORTS,
        OPCODE_DERIVE_TRAITS,
        OPCODE_ENUM_NAME
    );
}

#[inline]
pub fn execute_header() -> String {
    return format!(
        "/*\n\
    NOTE: THIS FILE IS AUTOGENERATED.\n\
    */\n\
    \n\
    use crate::instruction_arguments::{{{}, {}, {}}};\n\
    use crate::instruction::{};\n\
    \n\
    pub trait {} {{\n\
    \ttype Output;\n\
    \n\
    \tfn execute_instruction(&mut self, instruction: {}) -> Self::Output {{\n\
    \t\treturn match instruction {{\n",
        REGISTER_TYPE_NAME,
        ADDRESS_TYPE_NAME,
        IMMEDIATE_TYPE_NAME,
        OPCODE_ENUM_NAME,
        EXECUTE_TRAIT_NAME,
        OPCODE_ENUM_NAME
    );
}

#[inline]
pub fn opcode_impl_display_header() -> String {
    return format!(
        "impl core::fmt::Display for {} {{\n\
        \tfn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {{\n\
        \t\t return write!(f, \"{{}}\", match self {{\n",
        OPCODE_ENUM_NAME
    );
}

#[inline]
pub fn opcode_impl_into_bytes_header() -> String {
    return format!(
        "impl Into<Vec<u8>> for {} {{\n\
        \t fn into(self) -> Vec<u8> {{\n\
        \t\t return match self {{\n",
        OPCODE_ENUM_NAME
    );
}

#[inline]
pub fn opcode_impl_header() -> String {
    return format!("impl {} {{\n", OPCODE_ENUM_NAME);
}

#[inline]
pub fn opcode_new_header() -> String {
    return format!(
        "pub fn new(opcode: u8, registers: Vec<{}>, addresses: Vec<{}>, immediates: Vec<{}>) -> Option<Self> {{\n",
        REGISTER_TYPE_NAME,
        ADDRESS_TYPE_NAME,
        IMMEDIATE_TYPE_NAME
    );
}
