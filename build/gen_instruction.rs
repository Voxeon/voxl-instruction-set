use crate::config::*;
use crate::constants::*;
use rmod_gen::rust_component::Visibility;
use rmod_gen::{
    EnumVariant, RustEnum, RustFile, RustImplementation, RustMethod, RustText, RustVariable,
};
use std::fs::OpenOptions;
use std::io::Write;

macro_rules! create_property_method {
    ($generate_method_name:expr, $function_name:ident, $type_name:ident) => {
        fn $function_name(instructions: &InstructionDetails) -> RustMethod {
            let mut method = RustMethod::new($generate_method_name)
                .with_fn_type("const")
                .with_visibility(Visibility::Public)
                .with_argument("opcode: u8")
                .with_return_type("Option<usize>");

            let body = format!(
                "return Some(match opcode {{\n{}\n\t_ => return None,\n}});\n",
                instructions
                    .iter()
                    .map(|instruction| {
                        format!(
                            "\t{} => {}, //{}\n",
                            instruction.opcode_num,
                            instruction
                                .fields
                                .iter()
                                .filter(|field| field.as_str() == $type_name)
                                .count(),
                            &instruction.name
                        )
                    })
                    .collect::<String>()
            );

            method.set_body(&body);

            return method;
        }
    };
}

pub fn generate_instruction_file(instruction_details: &InstructionDetails) {
    let mut file = match OpenOptions::new()
        .create(true)
        .write(true)
        .truncate(true)
        .open(OPCODE_OUTPUT_PATH)
    {
        Ok(f) => f,
        Err(e) => {
            panic!(
                "Failed to open the file {}. Error: {}",
                INSTRUCTION_SET_PATH, e
            );
        }
    };

    let mut rust_file = RustFile::new()
        .with_top_string("/*\nNOTE: THIS FILE IS AUTOGENERATED.\n*/\n")
        .with_import(&format!(
            "use crate::instruction_arguments::{{{}, {}, {}, {}}}",
            REGISTER_TYPE_NAME,
            ADDRESS_TYPE_NAME,
            IMMEDIATE_TYPE_NAME,
            INSTRUCTION_ARGUMENT_TRAIT_NAME
        ));

    for import in BASE_IMPORTS {
        rust_file.push_import(import);
    }

    rust_file.push_component(create_opcode_enum(instruction_details).into());

    rust_file.push_component(create_opcode_impl(instruction_details).into());

    rust_file.push_component(generate_display_impl(instruction_details).into());

    rust_file.push_component(generate_into_bytes_trait(instruction_details).into());

    file.write_all(rust_file.into_rust_code().as_bytes())
        .expect("Failed to write generated code.");
}

fn create_opcode_enum(instruction_details: &InstructionDetails) -> RustEnum {
    let mut opcode_enum = RustEnum::new(OPCODE_ENUM_NAME)
        .with_cfg(OPCODE_DERIVE_TRAITS)
        .with_visibility(Visibility::Public);

    for instruction in instruction_details {
        let mut builder = EnumVariant::build(&instruction.name);

        for field in &instruction.fields {
            builder.push_value(&field);
        }

        opcode_enum.push_variant(builder.build());
    }

    return opcode_enum;
}

fn create_opcode_impl(opcodes: &InstructionDetails) -> RustImplementation {
    let mut opcode_impl = RustImplementation::new(OPCODE_ENUM_NAME);

    opcode_impl.push_component(generate_ordering_array(opcodes).into());
    opcode_impl.push_component(RustText::new("").into());
    opcode_impl.push_component(generate_new_opcode_method(opcodes).into());
    opcode_impl.push_component(generate_register_method(opcodes).into());
    opcode_impl.push_component(generate_address_method(opcodes).into());
    opcode_impl.push_component(generate_immediate_method(opcodes).into());
    opcode_impl.push_component(generate_opcode_from_name_method(opcodes).into());
    opcode_impl.push_component(generate_type_ordering_function().into());

    return opcode_impl;
}

fn generate_opcode_from_name_method(instructions: &InstructionDetails) -> RustMethod {
    let mut method = RustMethod::new("from_string")
        .with_visibility(Visibility::Public)
        .with_argument("opcode: &str")
        .with_return_type("Option<u8>");

    let body = format!(
        "return Some(match opcode {{\n{}\n\t_ => return None,\n}});\n",
        instructions
            .iter()
            .map(|instruction| {
                format!(
                    "\t\"{}\" => {}, //{}\n",
                    &instruction.short_name, instruction.opcode_num, &instruction.name
                )
            })
            .collect::<String>()
    );

    method.set_body(&body);

    return method;
}

create_property_method!(
    OPCODE_REGISTER_COUNT_METHOD_HEADER,
    generate_register_method,
    REGISTER_TYPE_NAME
);

create_property_method!(
    OPCODE_ADDRESS_COUNT_METHOD_HEADER,
    generate_address_method,
    ADDRESS_TYPE_NAME
);

create_property_method!(
    OPCODE_IMMEDIATE_COUNT_METHOD_HEADER,
    generate_immediate_method,
    IMMEDIATE_TYPE_NAME
);

fn generate_new_opcode_method(instructions: &InstructionDetails) -> RustMethod {
    let mut method = RustMethod::new("new")
        .with_argument("opcode: u8")
        .with_argument(&format!("registers: Vec<{}>", REGISTER_TYPE_NAME))
        .with_argument(&format!("addresses: Vec<{}>", ADDRESS_TYPE_NAME))
        .with_argument(&format!("immediates: Vec<{}>", IMMEDIATE_TYPE_NAME))
        .with_return_type("Option<Self>")
        .with_visibility(Visibility::Public);

    let mut body: String = NEW_OPCODE_OPENING_IF.join("\n");

    body.push('\n');
    body.push('\n');

    body.push_str(&format!(
        "return Some(match opcode {{\n{}\t_ => return None,\n}});",
        instructions
            .iter()
            .map(|instruction| {
                let mut arg_fields = String::new();
                let mut reg_i = 0;
                let mut add_i = 0;
                let mut imm_i = 0;

                for field in &instruction.fields {
                    if field == REGISTER_TYPE_NAME {
                        arg_fields.push_str(&format!("registers[{}], ", reg_i));

                        reg_i += 1;
                    } else if field == ADDRESS_TYPE_NAME {
                        arg_fields.push_str(&format!("addresses[{}], ", add_i));

                        add_i += 1;
                    } else if field == IMMEDIATE_TYPE_NAME {
                        arg_fields.push_str(&format!("immediates[{}], ", imm_i));

                        imm_i += 1;
                    }
                }

                if arg_fields.len() > 0 {
                    // Remove ", "
                    arg_fields.pop();
                    arg_fields.pop();

                    format!(
                        "\t{} => Self::{}({}),\n",
                        instruction.opcode_num, &instruction.name, arg_fields
                    )
                } else {
                    format!(
                        "\t{} => Self::{},\n",
                        instruction.opcode_num, &instruction.name
                    )
                }
            })
            .collect::<String>()
    ));

    method.set_body(&body);

    return method;
}

fn generate_into_bytes_trait(instructions: &InstructionDetails) -> RustImplementation {
    let mut into_trait = RustImplementation::new_for("Into<Vec<u8>>", OPCODE_ENUM_NAME);
    let method = RustMethod::new("into")
        .with_argument("self")
        .with_return_type("Vec<u8>")
        .with_body(&format!(
            "return match self {{\n{}}};\n",
            instructions
                .iter()
                .map(|instruction| {
                    let mut r_count = 0;
                    let mut a_count = 0;
                    let mut i_count = 0;

                    for field in &instruction.fields {
                        if field == REGISTER_TYPE_NAME {
                            r_count += 1;
                        } else if field == ADDRESS_TYPE_NAME {
                            a_count += 1;
                        } else if field == IMMEDIATE_TYPE_NAME {
                            i_count += 1;
                        }
                    }

                    let mut fields_string = String::new();
                    let mut rhs_string =
                        format!("{{\n\t\tlet mut v = vec![{}];\n", instruction.opcode_num);

                    for i in 0..i_count {
                        if i == 0 {
                            fields_string.push_str("i, ");
                            rhs_string.push_str(&format!(
                                "\t\tv.extend_from_slice(&Into::<[u8; {}::BYTES]>::into(i));\n",
                                IMMEDIATE_TYPE_NAME
                            ));
                        } else {
                            fields_string.push_str(&format!("i{}, ", i));
                            rhs_string.push_str(&format!(
                                "\t\tv.extend_from_slice(&Into::<[u8; {}::BYTES]>::into(i{}));\n",
                                IMMEDIATE_TYPE_NAME, i
                            ));
                        }
                    }

                    fn register_name(i: u64) -> String {
                        if i == 0 {
                            return "r".to_string();
                        } else {
                            return format!("r{}", i);
                        }
                    }

                    for i in 0..r_count {
                        fields_string.push_str(&format!("{}, ", register_name(i)));

                        if i > 0 && i % 2 == 1 {
                            rhs_string.push_str(&format!(
                                "\t\tv.push(({} as u8) << 4 | ({} as u8));\n",
                                register_name(i - 1),
                                register_name(i)
                            ));
                        } else if i == r_count - 1 {
                            rhs_string.push_str(&format!(
                                "\t\tv.push(({} as u8) << 4);\n",
                                register_name(i)
                            ));
                        }
                    }

                    for i in 0..a_count {
                        if i == 0 {
                            fields_string.push_str("a, ");
                            rhs_string.push_str(&format!(
                                "\t\tv.extend_from_slice(&Into::<[u8; {}::BYTES]>::into(a));\n",
                                ADDRESS_TYPE_NAME
                            ));
                        } else {
                            fields_string.push_str(&format!("a{}, ", i));
                            rhs_string.push_str(&format!(
                                "\t\tv.extend_from_slice(&Into::<[u8; {}::BYTES]>::into(a{}));\n",
                                ADDRESS_TYPE_NAME, i
                            ));
                        }
                    }

                    if fields_string.len() > 1 {
                        fields_string.pop(); // remove trailing space
                        fields_string.pop(); // remove trailing comma

                        fields_string = format!("({})", fields_string);
                    }

                    if i_count == 0 && r_count == 0 && a_count == 0 {
                        rhs_string = format!("vec![{}]", instruction.opcode_num);
                    } else {
                        rhs_string = format!("{}\t\tv\n\t}}", rhs_string);
                    }

                    format!(
                        "\tSelf::{}{} => {},\n",
                        instruction.name, fields_string, rhs_string
                    )
                })
                .collect::<String>()
        ));

    into_trait.push_component(method.into());

    return into_trait;
}

fn generate_ordering_array(instructions: &InstructionDetails) -> RustVariable {
    let mut variable = RustVariable::new_const("ORDERING_ARRAY")
        .with_type(&format!("[&'static[u8]; {}]", instructions.len()));

    variable.set_value(&format!(
        "[{}]",
        instructions
            .iter()
            .map(|instruction| {
                format!(
                    "&[{}], ",
                    instruction
                        .argument_order
                        .iter()
                        .map(|char| {
                            if *char == 'r' {
                                "0, "
                            } else if *char == 'i' {
                                "1, "
                            } else if *char == 'a' {
                                "2, "
                            } else {
                                panic!("Unknown order symbol {}", char);
                            }
                        })
                        .collect::<String>()
                )
            })
            .collect::<String>()
    ));

    return variable;
}

fn generate_type_ordering_function() -> RustMethod {
    return RustMethod::new("get_type_for_index")
        .with_fn_type("const")
        .with_visibility(Visibility::Public)
        .with_argument("opcode: u8")
        .with_argument("index: usize")
        .with_return_type("Option<u8>")
        .with_body("if opcode as usize >= Self::ORDERING_ARRAY.len() {\n\treturn None;\n}\n\nif index >= Self::ORDERING_ARRAY[opcode as usize].len() {\n\treturn None;\n}\n\nreturn Some(Self::ORDERING_ARRAY[opcode as usize][index]);\n");
}

fn generate_display_impl(instructions: &InstructionDetails) -> RustImplementation {
    let mut display_impl = RustImplementation::new_for("core::fmt::Display", OPCODE_ENUM_NAME);

    let method = RustMethod::new("fmt")
        .with_argument("&self")
        .with_argument("f: &mut core::fmt::Formatter<'_>")
        .with_return_type("core::fmt::Result")
        .with_body(&format!(
            "return write!(f, \"{{}}\", match self {{\n{}}});",
            instructions
                .iter()
                .map(|instruction| {
                    let mut lhs = format!("\tSelf::{}", &instruction.name);

                    if instruction.fields.len() > 0 {
                        lhs.push('(');

                        for _ in 0..instruction.fields.len() - 1 {
                            lhs.push_str("_, ");
                        }

                        lhs.push_str("_)");
                    }

                    format!("{} => \"{}\",\n", lhs, &instruction.short_name)
                })
                .collect::<String>()
        ));

    display_impl.push_component(method.into());

    return display_impl;
}
