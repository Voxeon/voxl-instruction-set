/*
NOTE: THIS FILE IS AUTOGENERATED.
*/

use crate::Register;
use crate::Address;
use crate::Immediate;

use alloc::vec::Vec;

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum Instruction {
	Nop, 
	Syscall(Immediate), 
	Ldb(Immediate, Register), 
	Ldi(Immediate, Register), 
	Ldf(Immediate, Register), 
	Mov(Register, Register), 
	Push(Register), 
	Pop(Register), 
	Sget(Register, Register), 
	Malloc(Register, Register), 
	Malloci(Immediate, Register), 
	Free(Register), 
	Freea(Address), 
	Setb(Register, Register, Register), 
	Seti(Register, Register, Register), 
	Isetb(Immediate, Register, Register), 
	Iseti(Immediate, Register, Register), 
	Getb(Register, Register, Register), 
	Geti(Register, Register, Register), 
	Igetb(Immediate, Register, Register), 
	Igeti(Immediate, Register, Register), 
	Last(Register, Register), 
	Length(Register, Register), 
	Clone(Register, Register), 
	Copy(Register, Register, Register, Register, Register), 
	Copyi(Immediate, Immediate, Immediate, Register, Register), 
	Addi(Register, Register, Register), 
	Subi(Register, Register, Register), 
	Muli(Register, Register, Register), 
	Divi(Register, Register, Register), 
	Modi(Register, Register, Register), 
	Addu(Register, Register, Register), 
	Subu(Register, Register, Register), 
	Mulu(Register, Register, Register), 
	Divu(Register, Register, Register), 
	Modu(Register, Register, Register), 
	Addf(Register, Register, Register), 
	Subf(Register, Register, Register), 
	Mulf(Register, Register, Register), 
	Divf(Register, Register, Register), 
	Rotl(Register, Register), 
	Rotli(Immediate, Register), 
	Rotr(Register, Register), 
	Rotri(Immediate, Register), 
	Sll(Register, Register), 
	Slli(Immediate, Register), 
	Srl(Register, Register), 
	Srli(Immediate, Register), 
	Not(Register), 
	And(Register, Register, Register), 
	Or(Register, Register, Register), 
	Xor(Register, Register, Register), 
	Cmp(Register, Register), 
	Cmpi(Register, Register), 
	Cmpf(Register, Register), 
	Jmp(Address), 
	Jeq(Address), 
	Jne(Address), 
	Jge(Address), 
	Jgt(Address), 
	Jle(Address), 
	Jlt(Address), 
	I2f(Register), 
	F2i(Register), 
	Swpa(Address, Address), 
	Swpar(Register, Register), 
	Swpr(Register, Register), 
	Call(Address), 
	Ret, 
	Halt, 
}

impl Instruction {
	pub const fn register_count(opcode: u8) -> Option<usize> {
		 return Some(match opcode {
			0 => 0, //Nop
			1 => 0, //Syscall
			2 => 1, //Ldb
			3 => 1, //Ldi
			4 => 1, //Ldf
			5 => 2, //Mov
			6 => 1, //Push
			7 => 1, //Pop
			8 => 2, //Sget
			9 => 2, //Malloc
			10 => 1, //Malloci
			11 => 1, //Free
			12 => 0, //Freea
			13 => 3, //Setb
			14 => 3, //Seti
			15 => 2, //Isetb
			16 => 2, //Iseti
			17 => 3, //Getb
			18 => 3, //Geti
			19 => 2, //Igetb
			20 => 2, //Igeti
			21 => 2, //Last
			22 => 2, //Length
			23 => 2, //Clone
			24 => 5, //Copy
			25 => 2, //Copyi
			26 => 3, //Addi
			27 => 3, //Subi
			28 => 3, //Muli
			29 => 3, //Divi
			30 => 3, //Modi
			31 => 3, //Addu
			32 => 3, //Subu
			33 => 3, //Mulu
			34 => 3, //Divu
			35 => 3, //Modu
			36 => 3, //Addf
			37 => 3, //Subf
			38 => 3, //Mulf
			39 => 3, //Divf
			40 => 2, //Rotl
			41 => 1, //Rotli
			42 => 2, //Rotr
			43 => 1, //Rotri
			44 => 2, //Sll
			45 => 1, //Slli
			46 => 2, //Srl
			47 => 1, //Srli
			48 => 1, //Not
			49 => 3, //And
			50 => 3, //Or
			51 => 3, //Xor
			52 => 2, //Cmp
			53 => 2, //Cmpi
			54 => 2, //Cmpf
			55 => 0, //Jmp
			56 => 0, //Jeq
			57 => 0, //Jne
			58 => 0, //Jge
			59 => 0, //Jgt
			60 => 0, //Jle
			61 => 0, //Jlt
			62 => 1, //I2f
			63 => 1, //F2i
			64 => 0, //Swpa
			65 => 2, //Swpar
			66 => 2, //Swpr
			67 => 0, //Call
			68 => 0, //Ret
			69 => 0, //Halt
			_ => return None,
		});
	}

	pub const fn address_count(opcode: u8) -> Option<usize> {
		 return Some(match opcode {
			0 => 0, //Nop
			1 => 0, //Syscall
			2 => 0, //Ldb
			3 => 0, //Ldi
			4 => 0, //Ldf
			5 => 0, //Mov
			6 => 0, //Push
			7 => 0, //Pop
			8 => 0, //Sget
			9 => 0, //Malloc
			10 => 0, //Malloci
			11 => 0, //Free
			12 => 1, //Freea
			13 => 0, //Setb
			14 => 0, //Seti
			15 => 0, //Isetb
			16 => 0, //Iseti
			17 => 0, //Getb
			18 => 0, //Geti
			19 => 0, //Igetb
			20 => 0, //Igeti
			21 => 0, //Last
			22 => 0, //Length
			23 => 0, //Clone
			24 => 0, //Copy
			25 => 0, //Copyi
			26 => 0, //Addi
			27 => 0, //Subi
			28 => 0, //Muli
			29 => 0, //Divi
			30 => 0, //Modi
			31 => 0, //Addu
			32 => 0, //Subu
			33 => 0, //Mulu
			34 => 0, //Divu
			35 => 0, //Modu
			36 => 0, //Addf
			37 => 0, //Subf
			38 => 0, //Mulf
			39 => 0, //Divf
			40 => 0, //Rotl
			41 => 0, //Rotli
			42 => 0, //Rotr
			43 => 0, //Rotri
			44 => 0, //Sll
			45 => 0, //Slli
			46 => 0, //Srl
			47 => 0, //Srli
			48 => 0, //Not
			49 => 0, //And
			50 => 0, //Or
			51 => 0, //Xor
			52 => 0, //Cmp
			53 => 0, //Cmpi
			54 => 0, //Cmpf
			55 => 1, //Jmp
			56 => 1, //Jeq
			57 => 1, //Jne
			58 => 1, //Jge
			59 => 1, //Jgt
			60 => 1, //Jle
			61 => 1, //Jlt
			62 => 0, //I2f
			63 => 0, //F2i
			64 => 2, //Swpa
			65 => 0, //Swpar
			66 => 0, //Swpr
			67 => 1, //Call
			68 => 0, //Ret
			69 => 0, //Halt
			_ => return None,
		});
	}

	pub const fn immediate_count(opcode: u8) -> Option<usize> {
		 return Some(match opcode {
			0 => 0, //Nop
			1 => 1, //Syscall
			2 => 1, //Ldb
			3 => 1, //Ldi
			4 => 1, //Ldf
			5 => 0, //Mov
			6 => 0, //Push
			7 => 0, //Pop
			8 => 0, //Sget
			9 => 0, //Malloc
			10 => 1, //Malloci
			11 => 0, //Free
			12 => 0, //Freea
			13 => 0, //Setb
			14 => 0, //Seti
			15 => 1, //Isetb
			16 => 1, //Iseti
			17 => 0, //Getb
			18 => 0, //Geti
			19 => 1, //Igetb
			20 => 1, //Igeti
			21 => 0, //Last
			22 => 0, //Length
			23 => 0, //Clone
			24 => 0, //Copy
			25 => 3, //Copyi
			26 => 0, //Addi
			27 => 0, //Subi
			28 => 0, //Muli
			29 => 0, //Divi
			30 => 0, //Modi
			31 => 0, //Addu
			32 => 0, //Subu
			33 => 0, //Mulu
			34 => 0, //Divu
			35 => 0, //Modu
			36 => 0, //Addf
			37 => 0, //Subf
			38 => 0, //Mulf
			39 => 0, //Divf
			40 => 0, //Rotl
			41 => 1, //Rotli
			42 => 0, //Rotr
			43 => 1, //Rotri
			44 => 0, //Sll
			45 => 1, //Slli
			46 => 0, //Srl
			47 => 1, //Srli
			48 => 0, //Not
			49 => 0, //And
			50 => 0, //Or
			51 => 0, //Xor
			52 => 0, //Cmp
			53 => 0, //Cmpi
			54 => 0, //Cmpf
			55 => 0, //Jmp
			56 => 0, //Jeq
			57 => 0, //Jne
			58 => 0, //Jge
			59 => 0, //Jgt
			60 => 0, //Jle
			61 => 0, //Jlt
			62 => 0, //I2f
			63 => 0, //F2i
			64 => 0, //Swpa
			65 => 0, //Swpar
			66 => 0, //Swpr
			67 => 0, //Call
			68 => 0, //Ret
			69 => 0, //Halt
			_ => return None,
		});
	}

	pub fn new(opcode: u8, registers: Vec<Register>, addresses: Vec<Address>, immediates: Vec<Immediate>) -> Option<Self> {
		if registers.len() != Self::register_count(opcode)? || addresses.len() != Self::address_count(opcode)? || immediates.len() != Self::immediate_count(opcode)? {
			return None;
		}

		return Some(match opcode {
			0 => Self::Nop,
			1 => Self::Syscall(immediates[0]),
			2 => Self::Ldb(immediates[0], registers[0]),
			3 => Self::Ldi(immediates[0], registers[0]),
			4 => Self::Ldf(immediates[0], registers[0]),
			5 => Self::Mov(registers[0], registers[1]),
			6 => Self::Push(registers[0]),
			7 => Self::Pop(registers[0]),
			8 => Self::Sget(registers[0], registers[1]),
			9 => Self::Malloc(registers[0], registers[1]),
			10 => Self::Malloci(immediates[0], registers[0]),
			11 => Self::Free(registers[0]),
			12 => Self::Freea(addresses[0]),
			13 => Self::Setb(registers[0], registers[1], registers[2]),
			14 => Self::Seti(registers[0], registers[1], registers[2]),
			15 => Self::Isetb(immediates[0], registers[0], registers[1]),
			16 => Self::Iseti(immediates[0], registers[0], registers[1]),
			17 => Self::Getb(registers[0], registers[1], registers[2]),
			18 => Self::Geti(registers[0], registers[1], registers[2]),
			19 => Self::Igetb(immediates[0], registers[0], registers[1]),
			20 => Self::Igeti(immediates[0], registers[0], registers[1]),
			21 => Self::Last(registers[0], registers[1]),
			22 => Self::Length(registers[0], registers[1]),
			23 => Self::Clone(registers[0], registers[1]),
			24 => Self::Copy(registers[0], registers[1], registers[2], registers[3], registers[4]),
			25 => Self::Copyi(immediates[0], immediates[1], immediates[2], registers[0], registers[1]),
			26 => Self::Addi(registers[0], registers[1], registers[2]),
			27 => Self::Subi(registers[0], registers[1], registers[2]),
			28 => Self::Muli(registers[0], registers[1], registers[2]),
			29 => Self::Divi(registers[0], registers[1], registers[2]),
			30 => Self::Modi(registers[0], registers[1], registers[2]),
			31 => Self::Addu(registers[0], registers[1], registers[2]),
			32 => Self::Subu(registers[0], registers[1], registers[2]),
			33 => Self::Mulu(registers[0], registers[1], registers[2]),
			34 => Self::Divu(registers[0], registers[1], registers[2]),
			35 => Self::Modu(registers[0], registers[1], registers[2]),
			36 => Self::Addf(registers[0], registers[1], registers[2]),
			37 => Self::Subf(registers[0], registers[1], registers[2]),
			38 => Self::Mulf(registers[0], registers[1], registers[2]),
			39 => Self::Divf(registers[0], registers[1], registers[2]),
			40 => Self::Rotl(registers[0], registers[1]),
			41 => Self::Rotli(immediates[0], registers[0]),
			42 => Self::Rotr(registers[0], registers[1]),
			43 => Self::Rotri(immediates[0], registers[0]),
			44 => Self::Sll(registers[0], registers[1]),
			45 => Self::Slli(immediates[0], registers[0]),
			46 => Self::Srl(registers[0], registers[1]),
			47 => Self::Srli(immediates[0], registers[0]),
			48 => Self::Not(registers[0]),
			49 => Self::And(registers[0], registers[1], registers[2]),
			50 => Self::Or(registers[0], registers[1], registers[2]),
			51 => Self::Xor(registers[0], registers[1], registers[2]),
			52 => Self::Cmp(registers[0], registers[1]),
			53 => Self::Cmpi(registers[0], registers[1]),
			54 => Self::Cmpf(registers[0], registers[1]),
			55 => Self::Jmp(addresses[0]),
			56 => Self::Jeq(addresses[0]),
			57 => Self::Jne(addresses[0]),
			58 => Self::Jge(addresses[0]),
			59 => Self::Jgt(addresses[0]),
			60 => Self::Jle(addresses[0]),
			61 => Self::Jlt(addresses[0]),
			62 => Self::I2f(registers[0]),
			63 => Self::F2i(registers[0]),
			64 => Self::Swpa(addresses[0], addresses[1]),
			65 => Self::Swpar(registers[0], registers[1]),
			66 => Self::Swpr(registers[0], registers[1]),
			67 => Self::Call(addresses[0]),
			68 => Self::Ret,
			69 => Self::Halt,
			_ => return None,
		});
	}
}

impl core::fmt::Display for Instruction {
	fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
		 return write!(f, "{}", match self {
			Self::Nop => "nop",
			Self::Syscall(_) => "syscall",
			Self::Ldb(_, _) => "ldb",
			Self::Ldi(_, _) => "ldi",
			Self::Ldf(_, _) => "ldf",
			Self::Mov(_, _) => "mov",
			Self::Push(_) => "push",
			Self::Pop(_) => "pop",
			Self::Sget(_, _) => "sget",
			Self::Malloc(_, _) => "malloc",
			Self::Malloci(_, _) => "malloci",
			Self::Free(_) => "free",
			Self::Freea(_) => "freea",
			Self::Setb(_, _, _) => "setb",
			Self::Seti(_, _, _) => "seti",
			Self::Isetb(_, _, _) => "isetb",
			Self::Iseti(_, _, _) => "iseti",
			Self::Getb(_, _, _) => "getb",
			Self::Geti(_, _, _) => "geti",
			Self::Igetb(_, _, _) => "igetb",
			Self::Igeti(_, _, _) => "igeti",
			Self::Last(_, _) => "last",
			Self::Length(_, _) => "length",
			Self::Clone(_, _) => "clone",
			Self::Copy(_, _, _, _, _) => "copy",
			Self::Copyi(_, _, _, _, _) => "copyi",
			Self::Addi(_, _, _) => "addi",
			Self::Subi(_, _, _) => "subi",
			Self::Muli(_, _, _) => "muli",
			Self::Divi(_, _, _) => "divi",
			Self::Modi(_, _, _) => "modi",
			Self::Addu(_, _, _) => "addu",
			Self::Subu(_, _, _) => "subu",
			Self::Mulu(_, _, _) => "mulu",
			Self::Divu(_, _, _) => "divu",
			Self::Modu(_, _, _) => "modu",
			Self::Addf(_, _, _) => "addf",
			Self::Subf(_, _, _) => "subf",
			Self::Mulf(_, _, _) => "mulf",
			Self::Divf(_, _, _) => "divf",
			Self::Rotl(_, _) => "rotl",
			Self::Rotli(_, _) => "rotli",
			Self::Rotr(_, _) => "rotr",
			Self::Rotri(_, _) => "rotri",
			Self::Sll(_, _) => "sll",
			Self::Slli(_, _) => "slli",
			Self::Srl(_, _) => "srl",
			Self::Srli(_, _) => "srli",
			Self::Not(_) => "not",
			Self::And(_, _, _) => "and",
			Self::Or(_, _, _) => "or",
			Self::Xor(_, _, _) => "xor",
			Self::Cmp(_, _) => "cmp",
			Self::Cmpi(_, _) => "cmpi",
			Self::Cmpf(_, _) => "cmpf",
			Self::Jmp(_) => "jmp",
			Self::Jeq(_) => "jeq",
			Self::Jne(_) => "jne",
			Self::Jge(_) => "jge",
			Self::Jgt(_) => "jgt",
			Self::Jle(_) => "jle",
			Self::Jlt(_) => "jlt",
			Self::I2f(_) => "i2f",
			Self::F2i(_) => "f2i",
			Self::Swpa(_, _) => "swpa",
			Self::Swpar(_, _) => "swpar",
			Self::Swpr(_, _) => "swpr",
			Self::Call(_) => "call",
			Self::Ret => "ret",
			Self::Halt => "halt",
		});
	}
}

