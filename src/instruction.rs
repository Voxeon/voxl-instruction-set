use crate::instruction_arguments::{Address, Immediate, InstructionArgument, Register};
use alloc::vec;
use alloc::vec::Vec;

/*
NOTE: THIS FILE IS AUTOGENERATED.
*/

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum Instruction {
    Nop,
    Syscall(Immediate),
    Ldb(Immediate, Register),
    Ldi(Immediate, Register),
    Ldf(Immediate, Register),
    Mov(Register, Register),
    Push(Register),
    Pop(Register),
    Sget(Register, Register),
    Malloc(Register, Register),
    Malloci(Immediate, Register),
    Free(Register),
    Freea(Address),
    Setb(Register, Register, Register),
    Seti(Register, Register, Register),
    Isetb(Immediate, Register, Register),
    Iseti(Immediate, Register, Register),
    Getb(Register, Register, Register),
    Geti(Register, Register, Register),
    Igetb(Immediate, Register, Register),
    Igeti(Immediate, Register, Register),
    Last(Register, Register),
    Length(Register, Register),
    Clone(Register, Register),
    Copy(Register, Register, Register, Register, Register),
    Copyi(Immediate, Immediate, Immediate, Register, Register),
    Addi(Register, Register, Register),
    Subi(Register, Register, Register),
    Muli(Register, Register, Register),
    Divi(Register, Register, Register),
    Modi(Register, Register, Register),
    Addu(Register, Register, Register),
    Subu(Register, Register, Register),
    Mulu(Register, Register, Register),
    Divu(Register, Register, Register),
    Modu(Register, Register, Register),
    Addf(Register, Register, Register),
    Subf(Register, Register, Register),
    Mulf(Register, Register, Register),
    Divf(Register, Register, Register),
    Rotl(Register, Register),
    Rotli(Immediate, Register),
    Rotr(Register, Register),
    Rotri(Immediate, Register),
    Sll(Register, Register),
    Slli(Immediate, Register),
    Srl(Register, Register),
    Srli(Immediate, Register),
    Not(Register),
    And(Register, Register, Register),
    Or(Register, Register, Register),
    Xor(Register, Register, Register),
    Cmp(Register, Register),
    Cmpi(Register, Register),
    Cmpf(Register, Register),
    Jmp(Address),
    Jeq(Address),
    Jne(Address),
    Jge(Address),
    Jgt(Address),
    Jle(Address),
    Jlt(Address),
    I2f(Register),
    F2i(Register),
    Swpa(Address, Address),
    Swpar(Register, Register),
    Swpr(Register, Register),
    Call(Address),
    Ret,
    Halt,
}

impl Instruction {
    const ORDERING_ARRAY: [&'static [u8]; 70] = [
        &[],
        &[1],
        &[0, 1],
        &[0, 1],
        &[0, 1],
        &[0, 0],
        &[0],
        &[0],
        &[0, 0],
        &[0, 0],
        &[0, 1],
        &[0],
        &[2],
        &[0, 0, 0],
        &[0, 0, 0],
        &[0, 1, 0],
        &[0, 1, 0],
        &[0, 0, 0],
        &[0, 0, 0],
        &[0, 0, 1],
        &[0, 0, 1],
        &[0, 0],
        &[0, 0],
        &[0, 0],
        &[0, 0, 0, 0, 0],
        &[0, 1, 0, 1, 1],
        &[0, 0, 0],
        &[0, 0, 0],
        &[0, 0, 0],
        &[0, 0, 0],
        &[0, 0, 0],
        &[0, 0, 0],
        &[0, 0, 0],
        &[0, 0, 0],
        &[0, 0, 0],
        &[0, 0, 0],
        &[0, 0, 0],
        &[0, 0, 0],
        &[0, 0, 0],
        &[0, 0, 0],
        &[0, 0],
        &[0, 1],
        &[0, 0],
        &[0, 1],
        &[0, 0],
        &[0, 1],
        &[0, 0],
        &[0, 1],
        &[0],
        &[0, 0, 0],
        &[0, 0, 0],
        &[0, 0, 0],
        &[0, 0],
        &[0, 0],
        &[0, 0],
        &[2],
        &[2],
        &[2],
        &[2],
        &[2],
        &[2],
        &[2],
        &[0],
        &[0],
        &[2, 2],
        &[0, 0],
        &[0, 0],
        &[2],
        &[],
        &[],
    ];

    pub fn new(
        opcode: u8,
        registers: Vec<Register>,
        addresses: Vec<Address>,
        immediates: Vec<Immediate>,
    ) -> Option<Self> {
        if registers.len() != Self::register_count(opcode)?
            || addresses.len() != Self::address_count(opcode)?
            || immediates.len() != Self::immediate_count(opcode)?
        {
            return None;
        }

        return Some(match opcode {
            0 => Self::Nop,
            1 => Self::Syscall(immediates[0]),
            2 => Self::Ldb(immediates[0], registers[0]),
            3 => Self::Ldi(immediates[0], registers[0]),
            4 => Self::Ldf(immediates[0], registers[0]),
            5 => Self::Mov(registers[0], registers[1]),
            6 => Self::Push(registers[0]),
            7 => Self::Pop(registers[0]),
            8 => Self::Sget(registers[0], registers[1]),
            9 => Self::Malloc(registers[0], registers[1]),
            10 => Self::Malloci(immediates[0], registers[0]),
            11 => Self::Free(registers[0]),
            12 => Self::Freea(addresses[0]),
            13 => Self::Setb(registers[0], registers[1], registers[2]),
            14 => Self::Seti(registers[0], registers[1], registers[2]),
            15 => Self::Isetb(immediates[0], registers[0], registers[1]),
            16 => Self::Iseti(immediates[0], registers[0], registers[1]),
            17 => Self::Getb(registers[0], registers[1], registers[2]),
            18 => Self::Geti(registers[0], registers[1], registers[2]),
            19 => Self::Igetb(immediates[0], registers[0], registers[1]),
            20 => Self::Igeti(immediates[0], registers[0], registers[1]),
            21 => Self::Last(registers[0], registers[1]),
            22 => Self::Length(registers[0], registers[1]),
            23 => Self::Clone(registers[0], registers[1]),
            24 => Self::Copy(
                registers[0],
                registers[1],
                registers[2],
                registers[3],
                registers[4],
            ),
            25 => Self::Copyi(
                immediates[0],
                immediates[1],
                immediates[2],
                registers[0],
                registers[1],
            ),
            26 => Self::Addi(registers[0], registers[1], registers[2]),
            27 => Self::Subi(registers[0], registers[1], registers[2]),
            28 => Self::Muli(registers[0], registers[1], registers[2]),
            29 => Self::Divi(registers[0], registers[1], registers[2]),
            30 => Self::Modi(registers[0], registers[1], registers[2]),
            31 => Self::Addu(registers[0], registers[1], registers[2]),
            32 => Self::Subu(registers[0], registers[1], registers[2]),
            33 => Self::Mulu(registers[0], registers[1], registers[2]),
            34 => Self::Divu(registers[0], registers[1], registers[2]),
            35 => Self::Modu(registers[0], registers[1], registers[2]),
            36 => Self::Addf(registers[0], registers[1], registers[2]),
            37 => Self::Subf(registers[0], registers[1], registers[2]),
            38 => Self::Mulf(registers[0], registers[1], registers[2]),
            39 => Self::Divf(registers[0], registers[1], registers[2]),
            40 => Self::Rotl(registers[0], registers[1]),
            41 => Self::Rotli(immediates[0], registers[0]),
            42 => Self::Rotr(registers[0], registers[1]),
            43 => Self::Rotri(immediates[0], registers[0]),
            44 => Self::Sll(registers[0], registers[1]),
            45 => Self::Slli(immediates[0], registers[0]),
            46 => Self::Srl(registers[0], registers[1]),
            47 => Self::Srli(immediates[0], registers[0]),
            48 => Self::Not(registers[0]),
            49 => Self::And(registers[0], registers[1], registers[2]),
            50 => Self::Or(registers[0], registers[1], registers[2]),
            51 => Self::Xor(registers[0], registers[1], registers[2]),
            52 => Self::Cmp(registers[0], registers[1]),
            53 => Self::Cmpi(registers[0], registers[1]),
            54 => Self::Cmpf(registers[0], registers[1]),
            55 => Self::Jmp(addresses[0]),
            56 => Self::Jeq(addresses[0]),
            57 => Self::Jne(addresses[0]),
            58 => Self::Jge(addresses[0]),
            59 => Self::Jgt(addresses[0]),
            60 => Self::Jle(addresses[0]),
            61 => Self::Jlt(addresses[0]),
            62 => Self::I2f(registers[0]),
            63 => Self::F2i(registers[0]),
            64 => Self::Swpa(addresses[0], addresses[1]),
            65 => Self::Swpar(registers[0], registers[1]),
            66 => Self::Swpr(registers[0], registers[1]),
            67 => Self::Call(addresses[0]),
            68 => Self::Ret,
            69 => Self::Halt,
            _ => return None,
        });
    }

    pub const fn register_count(opcode: u8) -> Option<usize> {
        return Some(match opcode {
            0 => 0,  //Nop
            1 => 0,  //Syscall
            2 => 1,  //Ldb
            3 => 1,  //Ldi
            4 => 1,  //Ldf
            5 => 2,  //Mov
            6 => 1,  //Push
            7 => 1,  //Pop
            8 => 2,  //Sget
            9 => 2,  //Malloc
            10 => 1, //Malloci
            11 => 1, //Free
            12 => 0, //Freea
            13 => 3, //Setb
            14 => 3, //Seti
            15 => 2, //Isetb
            16 => 2, //Iseti
            17 => 3, //Getb
            18 => 3, //Geti
            19 => 2, //Igetb
            20 => 2, //Igeti
            21 => 2, //Last
            22 => 2, //Length
            23 => 2, //Clone
            24 => 5, //Copy
            25 => 2, //Copyi
            26 => 3, //Addi
            27 => 3, //Subi
            28 => 3, //Muli
            29 => 3, //Divi
            30 => 3, //Modi
            31 => 3, //Addu
            32 => 3, //Subu
            33 => 3, //Mulu
            34 => 3, //Divu
            35 => 3, //Modu
            36 => 3, //Addf
            37 => 3, //Subf
            38 => 3, //Mulf
            39 => 3, //Divf
            40 => 2, //Rotl
            41 => 1, //Rotli
            42 => 2, //Rotr
            43 => 1, //Rotri
            44 => 2, //Sll
            45 => 1, //Slli
            46 => 2, //Srl
            47 => 1, //Srli
            48 => 1, //Not
            49 => 3, //And
            50 => 3, //Or
            51 => 3, //Xor
            52 => 2, //Cmp
            53 => 2, //Cmpi
            54 => 2, //Cmpf
            55 => 0, //Jmp
            56 => 0, //Jeq
            57 => 0, //Jne
            58 => 0, //Jge
            59 => 0, //Jgt
            60 => 0, //Jle
            61 => 0, //Jlt
            62 => 1, //I2f
            63 => 1, //F2i
            64 => 0, //Swpa
            65 => 2, //Swpar
            66 => 2, //Swpr
            67 => 0, //Call
            68 => 0, //Ret
            69 => 0, //Halt

            _ => return None,
        });
    }

    pub const fn address_count(opcode: u8) -> Option<usize> {
        return Some(match opcode {
            0 => 0,  //Nop
            1 => 0,  //Syscall
            2 => 0,  //Ldb
            3 => 0,  //Ldi
            4 => 0,  //Ldf
            5 => 0,  //Mov
            6 => 0,  //Push
            7 => 0,  //Pop
            8 => 0,  //Sget
            9 => 0,  //Malloc
            10 => 0, //Malloci
            11 => 0, //Free
            12 => 1, //Freea
            13 => 0, //Setb
            14 => 0, //Seti
            15 => 0, //Isetb
            16 => 0, //Iseti
            17 => 0, //Getb
            18 => 0, //Geti
            19 => 0, //Igetb
            20 => 0, //Igeti
            21 => 0, //Last
            22 => 0, //Length
            23 => 0, //Clone
            24 => 0, //Copy
            25 => 0, //Copyi
            26 => 0, //Addi
            27 => 0, //Subi
            28 => 0, //Muli
            29 => 0, //Divi
            30 => 0, //Modi
            31 => 0, //Addu
            32 => 0, //Subu
            33 => 0, //Mulu
            34 => 0, //Divu
            35 => 0, //Modu
            36 => 0, //Addf
            37 => 0, //Subf
            38 => 0, //Mulf
            39 => 0, //Divf
            40 => 0, //Rotl
            41 => 0, //Rotli
            42 => 0, //Rotr
            43 => 0, //Rotri
            44 => 0, //Sll
            45 => 0, //Slli
            46 => 0, //Srl
            47 => 0, //Srli
            48 => 0, //Not
            49 => 0, //And
            50 => 0, //Or
            51 => 0, //Xor
            52 => 0, //Cmp
            53 => 0, //Cmpi
            54 => 0, //Cmpf
            55 => 1, //Jmp
            56 => 1, //Jeq
            57 => 1, //Jne
            58 => 1, //Jge
            59 => 1, //Jgt
            60 => 1, //Jle
            61 => 1, //Jlt
            62 => 0, //I2f
            63 => 0, //F2i
            64 => 2, //Swpa
            65 => 0, //Swpar
            66 => 0, //Swpr
            67 => 1, //Call
            68 => 0, //Ret
            69 => 0, //Halt

            _ => return None,
        });
    }

    pub const fn immediate_count(opcode: u8) -> Option<usize> {
        return Some(match opcode {
            0 => 0,  //Nop
            1 => 1,  //Syscall
            2 => 1,  //Ldb
            3 => 1,  //Ldi
            4 => 1,  //Ldf
            5 => 0,  //Mov
            6 => 0,  //Push
            7 => 0,  //Pop
            8 => 0,  //Sget
            9 => 0,  //Malloc
            10 => 1, //Malloci
            11 => 0, //Free
            12 => 0, //Freea
            13 => 0, //Setb
            14 => 0, //Seti
            15 => 1, //Isetb
            16 => 1, //Iseti
            17 => 0, //Getb
            18 => 0, //Geti
            19 => 1, //Igetb
            20 => 1, //Igeti
            21 => 0, //Last
            22 => 0, //Length
            23 => 0, //Clone
            24 => 0, //Copy
            25 => 3, //Copyi
            26 => 0, //Addi
            27 => 0, //Subi
            28 => 0, //Muli
            29 => 0, //Divi
            30 => 0, //Modi
            31 => 0, //Addu
            32 => 0, //Subu
            33 => 0, //Mulu
            34 => 0, //Divu
            35 => 0, //Modu
            36 => 0, //Addf
            37 => 0, //Subf
            38 => 0, //Mulf
            39 => 0, //Divf
            40 => 0, //Rotl
            41 => 1, //Rotli
            42 => 0, //Rotr
            43 => 1, //Rotri
            44 => 0, //Sll
            45 => 1, //Slli
            46 => 0, //Srl
            47 => 1, //Srli
            48 => 0, //Not
            49 => 0, //And
            50 => 0, //Or
            51 => 0, //Xor
            52 => 0, //Cmp
            53 => 0, //Cmpi
            54 => 0, //Cmpf
            55 => 0, //Jmp
            56 => 0, //Jeq
            57 => 0, //Jne
            58 => 0, //Jge
            59 => 0, //Jgt
            60 => 0, //Jle
            61 => 0, //Jlt
            62 => 0, //I2f
            63 => 0, //F2i
            64 => 0, //Swpa
            65 => 0, //Swpar
            66 => 0, //Swpr
            67 => 0, //Call
            68 => 0, //Ret
            69 => 0, //Halt

            _ => return None,
        });
    }

    pub fn from_string(opcode: &str) -> Option<u8> {
        return Some(match opcode {
            "nop" => 0,      //Nop
            "syscall" => 1,  //Syscall
            "ldb" => 2,      //Ldb
            "ldi" => 3,      //Ldi
            "ldf" => 4,      //Ldf
            "mov" => 5,      //Mov
            "push" => 6,     //Push
            "pop" => 7,      //Pop
            "sget" => 8,     //Sget
            "malloc" => 9,   //Malloc
            "malloci" => 10, //Malloci
            "free" => 11,    //Free
            "freea" => 12,   //Freea
            "setb" => 13,    //Setb
            "seti" => 14,    //Seti
            "isetb" => 15,   //Isetb
            "iseti" => 16,   //Iseti
            "getb" => 17,    //Getb
            "geti" => 18,    //Geti
            "igetb" => 19,   //Igetb
            "igeti" => 20,   //Igeti
            "last" => 21,    //Last
            "length" => 22,  //Length
            "clone" => 23,   //Clone
            "copy" => 24,    //Copy
            "copyi" => 25,   //Copyi
            "addi" => 26,    //Addi
            "subi" => 27,    //Subi
            "muli" => 28,    //Muli
            "divi" => 29,    //Divi
            "modi" => 30,    //Modi
            "addu" => 31,    //Addu
            "subu" => 32,    //Subu
            "mulu" => 33,    //Mulu
            "divu" => 34,    //Divu
            "modu" => 35,    //Modu
            "addf" => 36,    //Addf
            "subf" => 37,    //Subf
            "mulf" => 38,    //Mulf
            "divf" => 39,    //Divf
            "rotl" => 40,    //Rotl
            "rotli" => 41,   //Rotli
            "rotr" => 42,    //Rotr
            "rotri" => 43,   //Rotri
            "sll" => 44,     //Sll
            "slli" => 45,    //Slli
            "srl" => 46,     //Srl
            "srli" => 47,    //Srli
            "not" => 48,     //Not
            "and" => 49,     //And
            "or" => 50,      //Or
            "xor" => 51,     //Xor
            "cmp" => 52,     //Cmp
            "cmpi" => 53,    //Cmpi
            "cmpf" => 54,    //Cmpf
            "jmp" => 55,     //Jmp
            "jeq" => 56,     //Jeq
            "jne" => 57,     //Jne
            "jge" => 58,     //Jge
            "jgt" => 59,     //Jgt
            "jle" => 60,     //Jle
            "jlt" => 61,     //Jlt
            "i2f" => 62,     //I2f
            "f2i" => 63,     //F2i
            "swpa" => 64,    //Swpa
            "swpar" => 65,   //Swpar
            "swpr" => 66,    //Swpr
            "call" => 67,    //Call
            "ret" => 68,     //Ret
            "halt" => 69,    //Halt

            _ => return None,
        });
    }

    pub const fn get_type_for_index(opcode: u8, index: usize) -> Option<u8> {
        if opcode as usize >= Self::ORDERING_ARRAY.len() {
            return None;
        }

        if index >= Self::ORDERING_ARRAY[opcode as usize].len() {
            return None;
        }

        return Some(Self::ORDERING_ARRAY[opcode as usize][index]);
    }
}

impl core::fmt::Display for Instruction {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        return write!(
            f,
            "{}",
            match self {
                Self::Nop => "nop",
                Self::Syscall(_) => "syscall",
                Self::Ldb(_, _) => "ldb",
                Self::Ldi(_, _) => "ldi",
                Self::Ldf(_, _) => "ldf",
                Self::Mov(_, _) => "mov",
                Self::Push(_) => "push",
                Self::Pop(_) => "pop",
                Self::Sget(_, _) => "sget",
                Self::Malloc(_, _) => "malloc",
                Self::Malloci(_, _) => "malloci",
                Self::Free(_) => "free",
                Self::Freea(_) => "freea",
                Self::Setb(_, _, _) => "setb",
                Self::Seti(_, _, _) => "seti",
                Self::Isetb(_, _, _) => "isetb",
                Self::Iseti(_, _, _) => "iseti",
                Self::Getb(_, _, _) => "getb",
                Self::Geti(_, _, _) => "geti",
                Self::Igetb(_, _, _) => "igetb",
                Self::Igeti(_, _, _) => "igeti",
                Self::Last(_, _) => "last",
                Self::Length(_, _) => "length",
                Self::Clone(_, _) => "clone",
                Self::Copy(_, _, _, _, _) => "copy",
                Self::Copyi(_, _, _, _, _) => "copyi",
                Self::Addi(_, _, _) => "addi",
                Self::Subi(_, _, _) => "subi",
                Self::Muli(_, _, _) => "muli",
                Self::Divi(_, _, _) => "divi",
                Self::Modi(_, _, _) => "modi",
                Self::Addu(_, _, _) => "addu",
                Self::Subu(_, _, _) => "subu",
                Self::Mulu(_, _, _) => "mulu",
                Self::Divu(_, _, _) => "divu",
                Self::Modu(_, _, _) => "modu",
                Self::Addf(_, _, _) => "addf",
                Self::Subf(_, _, _) => "subf",
                Self::Mulf(_, _, _) => "mulf",
                Self::Divf(_, _, _) => "divf",
                Self::Rotl(_, _) => "rotl",
                Self::Rotli(_, _) => "rotli",
                Self::Rotr(_, _) => "rotr",
                Self::Rotri(_, _) => "rotri",
                Self::Sll(_, _) => "sll",
                Self::Slli(_, _) => "slli",
                Self::Srl(_, _) => "srl",
                Self::Srli(_, _) => "srli",
                Self::Not(_) => "not",
                Self::And(_, _, _) => "and",
                Self::Or(_, _, _) => "or",
                Self::Xor(_, _, _) => "xor",
                Self::Cmp(_, _) => "cmp",
                Self::Cmpi(_, _) => "cmpi",
                Self::Cmpf(_, _) => "cmpf",
                Self::Jmp(_) => "jmp",
                Self::Jeq(_) => "jeq",
                Self::Jne(_) => "jne",
                Self::Jge(_) => "jge",
                Self::Jgt(_) => "jgt",
                Self::Jle(_) => "jle",
                Self::Jlt(_) => "jlt",
                Self::I2f(_) => "i2f",
                Self::F2i(_) => "f2i",
                Self::Swpa(_, _) => "swpa",
                Self::Swpar(_, _) => "swpar",
                Self::Swpr(_, _) => "swpr",
                Self::Call(_) => "call",
                Self::Ret => "ret",
                Self::Halt => "halt",
            }
        );
    }
}

impl Into<Vec<u8>> for Instruction {
    fn into(self) -> Vec<u8> {
        return match self {
            Self::Nop => vec![0],
            Self::Syscall(i) => {
                let mut v = vec![1];
                v.extend_from_slice(&Into::<[u8; Immediate::BYTES]>::into(i));
                v
            }
            Self::Ldb(i, r) => {
                let mut v = vec![2];
                v.extend_from_slice(&Into::<[u8; Immediate::BYTES]>::into(i));
                v.push((r as u8) << 4);
                v
            }
            Self::Ldi(i, r) => {
                let mut v = vec![3];
                v.extend_from_slice(&Into::<[u8; Immediate::BYTES]>::into(i));
                v.push((r as u8) << 4);
                v
            }
            Self::Ldf(i, r) => {
                let mut v = vec![4];
                v.extend_from_slice(&Into::<[u8; Immediate::BYTES]>::into(i));
                v.push((r as u8) << 4);
                v
            }
            Self::Mov(r, r1) => {
                let mut v = vec![5];
                v.push((r as u8) << 4 | (r1 as u8));
                v
            }
            Self::Push(r) => {
                let mut v = vec![6];
                v.push((r as u8) << 4);
                v
            }
            Self::Pop(r) => {
                let mut v = vec![7];
                v.push((r as u8) << 4);
                v
            }
            Self::Sget(r, r1) => {
                let mut v = vec![8];
                v.push((r as u8) << 4 | (r1 as u8));
                v
            }
            Self::Malloc(r, r1) => {
                let mut v = vec![9];
                v.push((r as u8) << 4 | (r1 as u8));
                v
            }
            Self::Malloci(i, r) => {
                let mut v = vec![10];
                v.extend_from_slice(&Into::<[u8; Immediate::BYTES]>::into(i));
                v.push((r as u8) << 4);
                v
            }
            Self::Free(r) => {
                let mut v = vec![11];
                v.push((r as u8) << 4);
                v
            }
            Self::Freea(a) => {
                let mut v = vec![12];
                v.extend_from_slice(&Into::<[u8; Address::BYTES]>::into(a));
                v
            }
            Self::Setb(r, r1, r2) => {
                let mut v = vec![13];
                v.push((r as u8) << 4 | (r1 as u8));
                v.push((r2 as u8) << 4);
                v
            }
            Self::Seti(r, r1, r2) => {
                let mut v = vec![14];
                v.push((r as u8) << 4 | (r1 as u8));
                v.push((r2 as u8) << 4);
                v
            }
            Self::Isetb(i, r, r1) => {
                let mut v = vec![15];
                v.extend_from_slice(&Into::<[u8; Immediate::BYTES]>::into(i));
                v.push((r as u8) << 4 | (r1 as u8));
                v
            }
            Self::Iseti(i, r, r1) => {
                let mut v = vec![16];
                v.extend_from_slice(&Into::<[u8; Immediate::BYTES]>::into(i));
                v.push((r as u8) << 4 | (r1 as u8));
                v
            }
            Self::Getb(r, r1, r2) => {
                let mut v = vec![17];
                v.push((r as u8) << 4 | (r1 as u8));
                v.push((r2 as u8) << 4);
                v
            }
            Self::Geti(r, r1, r2) => {
                let mut v = vec![18];
                v.push((r as u8) << 4 | (r1 as u8));
                v.push((r2 as u8) << 4);
                v
            }
            Self::Igetb(i, r, r1) => {
                let mut v = vec![19];
                v.extend_from_slice(&Into::<[u8; Immediate::BYTES]>::into(i));
                v.push((r as u8) << 4 | (r1 as u8));
                v
            }
            Self::Igeti(i, r, r1) => {
                let mut v = vec![20];
                v.extend_from_slice(&Into::<[u8; Immediate::BYTES]>::into(i));
                v.push((r as u8) << 4 | (r1 as u8));
                v
            }
            Self::Last(r, r1) => {
                let mut v = vec![21];
                v.push((r as u8) << 4 | (r1 as u8));
                v
            }
            Self::Length(r, r1) => {
                let mut v = vec![22];
                v.push((r as u8) << 4 | (r1 as u8));
                v
            }
            Self::Clone(r, r1) => {
                let mut v = vec![23];
                v.push((r as u8) << 4 | (r1 as u8));
                v
            }
            Self::Copy(r, r1, r2, r3, r4) => {
                let mut v = vec![24];
                v.push((r as u8) << 4 | (r1 as u8));
                v.push((r2 as u8) << 4 | (r3 as u8));
                v.push((r4 as u8) << 4);
                v
            }
            Self::Copyi(i, i1, i2, r, r1) => {
                let mut v = vec![25];
                v.extend_from_slice(&Into::<[u8; Immediate::BYTES]>::into(i));
                v.extend_from_slice(&Into::<[u8; Immediate::BYTES]>::into(i1));
                v.extend_from_slice(&Into::<[u8; Immediate::BYTES]>::into(i2));
                v.push((r as u8) << 4 | (r1 as u8));
                v
            }
            Self::Addi(r, r1, r2) => {
                let mut v = vec![26];
                v.push((r as u8) << 4 | (r1 as u8));
                v.push((r2 as u8) << 4);
                v
            }
            Self::Subi(r, r1, r2) => {
                let mut v = vec![27];
                v.push((r as u8) << 4 | (r1 as u8));
                v.push((r2 as u8) << 4);
                v
            }
            Self::Muli(r, r1, r2) => {
                let mut v = vec![28];
                v.push((r as u8) << 4 | (r1 as u8));
                v.push((r2 as u8) << 4);
                v
            }
            Self::Divi(r, r1, r2) => {
                let mut v = vec![29];
                v.push((r as u8) << 4 | (r1 as u8));
                v.push((r2 as u8) << 4);
                v
            }
            Self::Modi(r, r1, r2) => {
                let mut v = vec![30];
                v.push((r as u8) << 4 | (r1 as u8));
                v.push((r2 as u8) << 4);
                v
            }
            Self::Addu(r, r1, r2) => {
                let mut v = vec![31];
                v.push((r as u8) << 4 | (r1 as u8));
                v.push((r2 as u8) << 4);
                v
            }
            Self::Subu(r, r1, r2) => {
                let mut v = vec![32];
                v.push((r as u8) << 4 | (r1 as u8));
                v.push((r2 as u8) << 4);
                v
            }
            Self::Mulu(r, r1, r2) => {
                let mut v = vec![33];
                v.push((r as u8) << 4 | (r1 as u8));
                v.push((r2 as u8) << 4);
                v
            }
            Self::Divu(r, r1, r2) => {
                let mut v = vec![34];
                v.push((r as u8) << 4 | (r1 as u8));
                v.push((r2 as u8) << 4);
                v
            }
            Self::Modu(r, r1, r2) => {
                let mut v = vec![35];
                v.push((r as u8) << 4 | (r1 as u8));
                v.push((r2 as u8) << 4);
                v
            }
            Self::Addf(r, r1, r2) => {
                let mut v = vec![36];
                v.push((r as u8) << 4 | (r1 as u8));
                v.push((r2 as u8) << 4);
                v
            }
            Self::Subf(r, r1, r2) => {
                let mut v = vec![37];
                v.push((r as u8) << 4 | (r1 as u8));
                v.push((r2 as u8) << 4);
                v
            }
            Self::Mulf(r, r1, r2) => {
                let mut v = vec![38];
                v.push((r as u8) << 4 | (r1 as u8));
                v.push((r2 as u8) << 4);
                v
            }
            Self::Divf(r, r1, r2) => {
                let mut v = vec![39];
                v.push((r as u8) << 4 | (r1 as u8));
                v.push((r2 as u8) << 4);
                v
            }
            Self::Rotl(r, r1) => {
                let mut v = vec![40];
                v.push((r as u8) << 4 | (r1 as u8));
                v
            }
            Self::Rotli(i, r) => {
                let mut v = vec![41];
                v.extend_from_slice(&Into::<[u8; Immediate::BYTES]>::into(i));
                v.push((r as u8) << 4);
                v
            }
            Self::Rotr(r, r1) => {
                let mut v = vec![42];
                v.push((r as u8) << 4 | (r1 as u8));
                v
            }
            Self::Rotri(i, r) => {
                let mut v = vec![43];
                v.extend_from_slice(&Into::<[u8; Immediate::BYTES]>::into(i));
                v.push((r as u8) << 4);
                v
            }
            Self::Sll(r, r1) => {
                let mut v = vec![44];
                v.push((r as u8) << 4 | (r1 as u8));
                v
            }
            Self::Slli(i, r) => {
                let mut v = vec![45];
                v.extend_from_slice(&Into::<[u8; Immediate::BYTES]>::into(i));
                v.push((r as u8) << 4);
                v
            }
            Self::Srl(r, r1) => {
                let mut v = vec![46];
                v.push((r as u8) << 4 | (r1 as u8));
                v
            }
            Self::Srli(i, r) => {
                let mut v = vec![47];
                v.extend_from_slice(&Into::<[u8; Immediate::BYTES]>::into(i));
                v.push((r as u8) << 4);
                v
            }
            Self::Not(r) => {
                let mut v = vec![48];
                v.push((r as u8) << 4);
                v
            }
            Self::And(r, r1, r2) => {
                let mut v = vec![49];
                v.push((r as u8) << 4 | (r1 as u8));
                v.push((r2 as u8) << 4);
                v
            }
            Self::Or(r, r1, r2) => {
                let mut v = vec![50];
                v.push((r as u8) << 4 | (r1 as u8));
                v.push((r2 as u8) << 4);
                v
            }
            Self::Xor(r, r1, r2) => {
                let mut v = vec![51];
                v.push((r as u8) << 4 | (r1 as u8));
                v.push((r2 as u8) << 4);
                v
            }
            Self::Cmp(r, r1) => {
                let mut v = vec![52];
                v.push((r as u8) << 4 | (r1 as u8));
                v
            }
            Self::Cmpi(r, r1) => {
                let mut v = vec![53];
                v.push((r as u8) << 4 | (r1 as u8));
                v
            }
            Self::Cmpf(r, r1) => {
                let mut v = vec![54];
                v.push((r as u8) << 4 | (r1 as u8));
                v
            }
            Self::Jmp(a) => {
                let mut v = vec![55];
                v.extend_from_slice(&Into::<[u8; Address::BYTES]>::into(a));
                v
            }
            Self::Jeq(a) => {
                let mut v = vec![56];
                v.extend_from_slice(&Into::<[u8; Address::BYTES]>::into(a));
                v
            }
            Self::Jne(a) => {
                let mut v = vec![57];
                v.extend_from_slice(&Into::<[u8; Address::BYTES]>::into(a));
                v
            }
            Self::Jge(a) => {
                let mut v = vec![58];
                v.extend_from_slice(&Into::<[u8; Address::BYTES]>::into(a));
                v
            }
            Self::Jgt(a) => {
                let mut v = vec![59];
                v.extend_from_slice(&Into::<[u8; Address::BYTES]>::into(a));
                v
            }
            Self::Jle(a) => {
                let mut v = vec![60];
                v.extend_from_slice(&Into::<[u8; Address::BYTES]>::into(a));
                v
            }
            Self::Jlt(a) => {
                let mut v = vec![61];
                v.extend_from_slice(&Into::<[u8; Address::BYTES]>::into(a));
                v
            }
            Self::I2f(r) => {
                let mut v = vec![62];
                v.push((r as u8) << 4);
                v
            }
            Self::F2i(r) => {
                let mut v = vec![63];
                v.push((r as u8) << 4);
                v
            }
            Self::Swpa(a, a1) => {
                let mut v = vec![64];
                v.extend_from_slice(&Into::<[u8; Address::BYTES]>::into(a));
                v.extend_from_slice(&Into::<[u8; Address::BYTES]>::into(a1));
                v
            }
            Self::Swpar(r, r1) => {
                let mut v = vec![65];
                v.push((r as u8) << 4 | (r1 as u8));
                v
            }
            Self::Swpr(r, r1) => {
                let mut v = vec![66];
                v.push((r as u8) << 4 | (r1 as u8));
                v
            }
            Self::Call(a) => {
                let mut v = vec![67];
                v.extend_from_slice(&Into::<[u8; Address::BYTES]>::into(a));
                v
            }
            Self::Ret => vec![68],
            Self::Halt => vec![69],
        };
    }
}
